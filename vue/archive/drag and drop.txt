<template>
  <div class="hello-world">
    <div class="container">
      <div
        class="item"
        draggable="true"
      >
        1
      </div>
      <div
        class="item"
        draggable="true"
      >
        2
      </div>
    </div>

    <div class="container">
      <div
        class="item"
        draggable="true"
      >
        3
      </div>
    </div>


    <Button
      label="Link"
    />
    <Button
      label="Save"
      icon="pi pi-spinner pi-spin"
      :loading="saving"
    />
  </div>
</template>

<script lang='ts'>
import { defineComponent, onMounted, ref } from 'vue';
import { useAppSettingsStore } from '@/stores/AppSettingsStore';

export default defineComponent({
  name: 'HelloWorld',
  async setup() {
    const store = useAppSettingsStore();
    const saving = ref(true);


    onMounted(() => {
      const draggables = document.querySelectorAll('.item');
      const containers = document.querySelectorAll('.container');

      draggables.forEach(item => {

        item.addEventListener('dragstart', () => {
          item.classList.add('dragging');
        });

        item.addEventListener('dragend', () => {
          item.classList.remove('dragging');
        });


      });

      containers.forEach(container => {
        container.addEventListener('dragover', e => {
          e.preventDefault(); // changes cursor
          const { element: afterElement } = getDragAfterElement(container, e.clientY);
          const dragged = document.querySelector('.dragging');
          if (afterElement == null) {
            container.appendChild(dragged);
          } else {
            container.insertBefore(dragged, afterElement);
          }
        });
      });


      function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.item:not(.dragging)')];


        return draggableElements.reduce((closest, el) => {
          const box = el.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;

          if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: el };
          } else {
            return closest;
          }
        }, { offset: Number.NEGATIVE_INFINITY });
      }


    });


    const loading = await new Promise<void>(resolve => {
      setTimeout(() => {
        console.log('yippie');
        resolve();
      }, 100);
    });


    return { loading, store, ref, saving };
  },
});
</script>

<style scoped>

.container {
  background-color: lightsalmon;
  padding: 1rem;
  width: 300px;
  margin-bottom: 2rem;
}

.item {
  padding: 1rem;
  margin: 1rem;
  background-color: white;
}

.dragging {
  opacity: .5;
}


a {
  color: #42b983;
}

button {
  margin-right: 10px;
}

label {
  margin: 0 0.5em;
  font-weight: bold;
}

code {
  background-color: #eee;
  padding: 2px 4px;
  border-radius: 4px;
  color: #304455;
}
</style>
